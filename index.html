<!DOCTYPE html>
<html>
  <head>
    <title></title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <!--<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">-->
    <!--<meta name="viewport" content="width=device-width, initial-scale=1.0">-->
    <!--This one seems to work all the time, but really small on ipad-->
    <!--<meta name="viewport" content="initial-scale=0.4">-->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="stylesheet" media="all" href="theme/css/default.css">
    <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
    <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
    <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
  </head>
  <body style="opacity: 0">
    <slides class="layout-widescreen">

      <slide class="logoslide nobackground">
	<article class="flexbox vcenter">
	  <span><img src="images/ug.jpeg"></span>
	</article>
      </slide>
      
      <slide class="title-slide segue nobackground">
	<aside class="gdbar"><img src="images/ug_128.png"></aside>
	<!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
	<hgroup class="auto-fadein">
	  <h1 data-config-title><!-- populated from slide_config.json --></h1>
	  <h2 data-config-subtitle><!-- populated from slide_config.json --></h2>
	  <p data-config-presenter><!-- populated from slide_config.json --></p>
	</hgroup>
      </slide>
      
      
      <!-- Content starts HERE! -->
        
        <slide>
            <hgroup>
                <h2>Análisis Semántico</h2>
            </hgroup>
            <article>
                Objetivo:
                <ul class="build">
                    <li>Asegurarse que el programa cumple con la definición del lenguaje.</li>
                    <li>Brindar mensajes de error útiles y entendibles.</li>
                </ul>
            </article>
        </slide>
        
        <slide>
            <hgroup>
                <h2>Análisis Semántico</h2>
            </hgroup>
            <article>
                Sintaxis:
                <ul>
                    <li>Trata sobre cómo se ve un programa.</li>
                    <li>Analiza su representación textual, la estructura.</li>
                    <li>Podemos utilizar una definición matemática muy precisa.</li>
                </ul>
                Semántica:
                <ul>
                    <li>Trata sobre qué significa un programa.</li>
                    <li>Una definición matemática precisa es múy difícil de obtener.</li>
                </ul>
            </article>
        </slide>
        
        <slide>
            <hgroup>
                <h2>Análisis Semántico</h2>
            </hgroup>
            <article>
                2 grandes clases de chequeos:
                <ul class="build">
                    <li>Chequeos estáticos
                        <ul class="build">
                            <li>Chequeos de unicidad</li>
                            <li>Chequeos de tipos.</li>
                            <li>Chequeos de control de flujo.</li>
                        </ul>
                    </li>
                    <li>Chequeos dinámicos.</li>
                </ul>
            </article>
        </slide>
        
        <slide>
            <hgroup>
                <h2>Análisis Semántico</h2>
                <h3>Control de flujo</h3>
            </hgroup>
            <article>
                <ul class="build">
                    <li>El control del flujo de un programa depende del contexto.</li>
                    <li>Ej.: Una sentencia <b>break</b> sólo es válida dentro de un while, for, switch.</li>
                </ul>
            </article>
        </slide>
        
        <slide>
            <hgroup>
                <h2>Análisis Semántico</h2>
                <h3>Unicidad</h3>
            </hgroup>
            <article>
                <ul class="build">
                    <li>Uso correcto (o incorrecto) de identificadores.</li>
                    <li>Ej.: Una variable debe ser definida antes de ser referenciada.</li>
                    <li>No se pueden representar con una gramática.</li>
                </ul>
            </article>
        </slide>
        
        <slide>
            <hgroup>
                <h2>Análisis Semántico</h2>
                <h3>Tipos</h3>
            </hgroup>
            <article>
                <ul class="build">
                    <li>Compatibilidad de tipos entre 2 o más operandos, o entre un operando y su operador, ej:</li>
                    <li>El tipo de retorno de una función debe coincidir con el tipo de su declaración.</li>
                    <li>Identificadores en una expresión deben ser de tipos 'compatibles'.</li>
                    <li>El lado izquiero de una asignación debe ser 'asignable'.</li>
                    <li>Los argumentos en la llamada a una función deben coincidir con la declaración de la función.</li>
                </ul>
            </article>
        </slide>
        
        <slide>
            <hgroup>
                <h2>Análisis Semántico</h2>
                <h3>Tipos</h3>
            </hgroup>
            <article>
                ¿Cómo sabemos si 2 operandos son <b>compatibles</b>?
            </article>
        </slide>
        
        <slide class="segue dark nobackground">
            <aside class="gdbar"><img src="images/ug_128.png"></aside>
            <hgroup class="auto-fadein">
                <h2>Sistema de tipos</h2>
                <h3>Análisis Semántico</h3>
            </hgroup>
        </slide>
        
        <slide>
            <hgroup>
                <h2>Análisis Semántico</h2>
                <h3>Sistema de Tipos</h3>
            </hgroup>
            <article>
                <ul class="build">
                    <li>Utilizado para los chequeos de tipos.</li>
                    <li>Incorpora los siguientes elementos:
                        <ul class="build">
                            <li>Construcciones sintácticas del lenguaje.</li>
                            <li>Concepto de tipo.</li>
                            <li>Reglas de asignación entre tipos y construcciones del lenguaje.</li>
                        </ul>
                    </li>
                </ul>
            </article>
        </slide>
        
        <slide>
            <hgroup>
                <h2>Análisis Semántico</h2>
                <h3>Sistema de Tipos</h3>
            </hgroup>
            <article>
                <ul class="build">
                    <li>Un Tipo incorpora los siguientes elementos:
                        <ul class="build">
                            <li>Connjunto de valores.</li>
                            <li>Conjunto de operaciones.</li>
                        </ul>
                    </li>
                </ul>
            </article>
        </slide>
        
        <slide>
            <hgroup>
                <h2>Tipos básicos</h2>
                <h3>Sistema de Tipos</h3>
            </hgroup>
            <article>
                <ul class="build">
                    <li>Dependen del lenguaje.</li>
                    <li>Tipos atómicos, ej:
                        <ul>
                            <li>char</li>
                            <li>int</li>
                            <li>float</li>
                            <li>boolean</li>
                        </ul>
                    </li>
                    <li>type_error: Tipo especial, que representa un error.</li>
                    <li>void: Denota la ausencia de un valor.</li>
                </ul>
            </article>
        </slide>
        
        <slide>
            <hgroup>
                <h2>Arreglos</h2>
                <h3>Sistema de Tipos</h3>
            </hgroup>
            <article>
                <ul class="build">
                    <li>El tipo de un arreglo consiste en el tipo de sus elementos, y la cantidad de estos.</li>
                    <li>
                        <ul>
                            <li>Ejemplo:</li>
                            <li>char[100] s;</li>
                            <li><b>array(char, 100)</b></li>
                        </ul>
                    </li>
                </ul>
            </article>
        </slide>
        
        <slide>
            <hgroup>
                <h2>Llamadas a funciones</h2>
                <h3>Sistema de Tipos</h3>
            </hgroup>
            <article>
                <ul class="build">
                    <li>El tipo de una llamada a una función consiste en el tipo de cada argumento, la cantidad y el orden de los mismos.</li>
                    <li>
                        <ul>
                            <li>Ejemplo:</li>
                            <li>boolean foo(String s, int a, float f);</li>
                            <li><b>function(boolean, String, int, float)</b></li>
                        </ul>
                    </li>
                </ul>
            </article>
        </slide>
        
        <slide class="segue dark nobackground">
            <aside class="gdbar"><img src="images/ug_128.png"></aside>
            <hgroup class="auto-fadein">
                <h2>Conversiones de Tipos</h2>
                <h3>Análisis Semántico</h3>
            </hgroup>
        </slide>
        
        <slide>
            <hgroup>
                <h2>Coerción de tipos</h2>
                <h3>Sistema de Tipos</h3>
            </hgroup>
            <article>
                <ul class="build">
                    <li>Conversión de tipos implícita entre 2 tipos.</li>
                    <li>
                        <ul>
                            <li>Ejemplo:</li>
                            <li>int a;</li>
                            <li>float a;</li>
                            <li>b = b + a;</li>
                        </ul>
                    </li>
                    <li>Dos formas:
                        <ul>
                            <li>Widening conversion (conversión a un tipo más 'grande').</li>
                            <li>Narrowing conversion (conversión a un tipo más 'pequeño').</li>
                        </ul>
                    </li>
                </ul>
            </article>
        </slide>
        
        <slide>
            <hgroup>
                <h2>Casting</h2>
                <h3>Sistema de Tipos</h3>
            </hgroup>
            <article>
                <ul class="build">
                    <li>Conversión de tipos explícita entre 2 tipos.</li>
                    <li>
                        <ul>
                            <li>Ejemplo:</li>
                            <li>int a;</li>
                            <li>float a;</li>
                            <li>a = (int)b + a;</li>
                        </ul>
                    </li>
                    <li>Dos formas:
                        <ul>
                            <li>Widening conversion (conversión a un tipo más 'grande').</li>
                            <li>Narrowing conversion (conversión a un tipo más 'pequeño').</li>
                        </ul>
                    </li>
                </ul>
            </article>
        </slide>
        
        <slide>
            <hgroup>
                <h2>Tabla de símbolos</h2>
            </hgroup>
            <article>
                <ul class="build">
                    <li>Permite almacenar información semántica sobre las construcciones del programa.</li>
                    <li>
                        <ul>
                            <li>Métodos</li>
                            <li>Variables</li>
                            <li>Scopes</li>
                        </ul>
                    </li>
                </ul>
            </article>
        </slide>
        
        <slide>
            <hgroup>
                <h2>Tabla de símbolos</h2>
                <h3>Scopes</h3>
            </hgroup>
            <article>
                <ul class="build">
                    <li>Un scope es la porción de código en la que un identificador es válido.</li>
                    <li>Un mismo identificador puede tener distintos significados en diferentes scopes.</li>
                    <li>
                        <ul>
                            <li>Tipos.</li>
                            <li>Variables.</li>
                        </ul>
                    </li>
                    <li>Esto significa que debemos mantener una tabla de símbolos por cada scope.</li>
                </ul>
            </article>
        </slide>
        
        <slide>
            <hgroup>
                <h2>Tabla de símbolos</h2>
                <h3>Operaciones</h3>
            </hgroup>
            <article>
                <ul class="build">
                    <li>La tabla de símbolos debe soportar las siguientes operaciones.</li>
                    <li>
                        <ul>
                            <li>lookup(id, scopeId)</li>
                            <li>getType(id, scopeId)</li>
                            <li>store(id, type, scopeId)</li>
                            <li>store(id, type, params, scopeId)</li>
                            <li>addScope(id)</li>
                        </ul>
                    </li>
                </ul>
            </article>
        </slide>
        
        <slide>
            <hgroup>
                <h2>Implementación</h2>
                <h3>Análisis Semántico</h3>
            </hgroup>
            <article>
                <ul class="build">
                    <li>Únicamente se validan semánticamente programas válidos de forma léxica y sintáctica.</li>
                    <li>Implementado sobre el AST, posiblemente requiera recorrerlo múltiples veces.</li>
                    <li>Comúnmente se utiliza una implementación recursiva.</li>
                    <li>Debe reportar tantos errores semánticos como sea posible.</li>
                </ul>
            </article>
        </slide>
        
        <slide>
            <hgroup>
                <h2>Implementación</h2>
                <h3>Análisis Semántico</h3>
            </hgroup>
            <article>
                <pre>
                    Ej: Program: a = e1 + e2
                    check(program p){
                        t1 = true;
                        p.exp.each(e) do
                            t1 &= check(e);
                        
                        return t1;
                    }
                    
                    check(location){
                        symbol = lookup(location.dest_var);
                        if symbol != null   // dest_var exists :D
                            symbol.type == checkWithType(location.exp);
                    }
                </pre>
            </article>
        </slide>
        
        <slide>
            <hgroup>
                <h2>Implementación</h2>
                <h3>Análisis Semántico</h3>
            </hgroup>
            <article>
                <pre>
                    checkWithType(exp){
                        t1 = checkWithType(exp.left);
                        t2 = checkWithType(exp.right);
                        return isValidOp(exp.operator, t1, t2);
                    }
                    
                    isValidOp(operator, lType, rType){
                        valid; 
                        if lType == rType   // no coercion needed :D
                            valid = operationsFor(lType).includes?(operator);
                        else
                            type = coerce(lType, rType);
                            valid = operationsFor(lType).includes?(operator);
                        
                        return valid;
                    }
                </pre>
            </article>
        </slide>
        
        <slide>
            <hgroup>
                <h2>Implementación</h2>
                <h3>Análisis Semántico</h3>
            </hgroup>
            <article>
                <pre>
                    operationsFor(type){
                        case type:
                        when type.to_s == 'int'
                            return ['+', '-', '*', '/', '%', '==', '!=']
                        when type.to_s == 'boolean'
                            return ['&&', '||', '!', '==', '!=']
                        when type.to_s == 'void'
                            return []
                        when type.to_s == 'error'
                            return []
                    }
                </pre>
            </article>
        </slide>
        
        <slide class="logoslide dark nobackground"></slide>
        
        <slide class="backdrop"></slide>
        
    </slides>
    <!--[if IE]>
      <script src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js"></script>
      <script>CFInstall.check({mode: 'overlay'});</script>
    <![endif]-->
  </body>
</html>
